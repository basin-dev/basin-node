package scratch

import (
	"net/http"
)

/*
Presumably anyone can call the node to attempt write, but will just be rejected if they don't have the right permissions.

But if we end up wanting to do some higher level authentication then this will be here.
*/
func authenticate(w http.ResponseWriter, r *http.Request) bool {
	return true
}

func handleAuth(pattern string, handler func(http.ResponseWriter, *http.Request)) {
	http.HandleFunc(pattern, func(w http.ResponseWriter, r *http.Request) {
		authenticated := authenticate(w, r)
		if !authenticated {
			return
		}

		handler(w, r)
	})
}

type writeBody struct {
	Url   string
	Value []byte
}

// TODO: This is where you can use net.Listen("unix") or something for alternate RPC communication. But how can you make this work with the autogenerated server?? Look into the above ListenAndServe function, this is what you would change.

// listener, err := net.Listen("tcp", addr)
// if err != nil {
// 	log.Fatal(err)
// }

// println("Listening at address", listener.Addr())

// http.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
// 	fmt.Fprint(w, "Hello. The server hears your request and responds.")
// })

// handleAuth("/requestSubscription", func(w http.ResponseWriter, r *http.Request) {
// 	switch r.Method {
// 	case "POST":
// 		var body []PermissionJson
// 		err := json.NewDecoder(r.Body).Decode(&body)
// 		url := util.GetUserDataUrl(b.Did, "producer.requests")
// 		val, err := json.Marshal(body)
// 		if err != nil {
// 			log.Println(err)
// 			return
// 		}
// 		err = b.WriteResource(ctx, url, val)
// 		w.WriteHeader(200)
// 		w.Write([]byte("Request was recieved successfully"))
// 	default:
// 		w.WriteHeader(400)
// 		w.Write([]byte("Invalid method, " + r.Method))
// 	}
// })

// // TODO: Need to perform authentication on the caller. Should have their DID and a credential to prove it!!!!
// handleAuth("/write", func(w http.ResponseWriter, r *http.Request) {
// 	if r.Method != "POST" {
// 		w.WriteHeader(400)
// 		w.Write([]byte("Invalid method, " + r.Method))
// 	}

// 	var bodyjson writeBody
// 	err := json.NewDecoder(r.Body).Decode(&bodyjson)
// 	if err != nil {
// 		w.WriteHeader(500)
// 		return
// 	}

// 	// TODO: Then further marshal and validate value based on the schema
// 	err = b.WriteResource(ctx, bodyjson.Url, bodyjson.Value)
// 	if err != nil {
// 		w.WriteHeader(500)
// 		w.Write([]byte("Error writing to resource: " + err.Error()))
// 		return
// 	}

// 	w.Write([]byte("true"))
// 	w.WriteHeader(200)
// })

// handleAuth("/read", func(w http.ResponseWriter, r *http.Request) {
// 	val, err := b.ReadResource(ctx, r.URL.Query().Get("url"))
// 	if err != nil {
// 		w.WriteHeader(500)
// 		w.Write([]byte("Error reading resource: " + err.Error()))
// 	}

// 	w.Write(val)
// 	w.WriteHeader(200)
// })

// log.Fatal(http.Serve(listener, nil))
